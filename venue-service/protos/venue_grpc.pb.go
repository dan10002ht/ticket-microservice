// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v3.21.12
// source: venue.proto

package protos

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	VenueService_CreateVenue_FullMethodName         = "/venue.VenueService/CreateVenue"
	VenueService_GetVenue_FullMethodName            = "/venue.VenueService/GetVenue"
	VenueService_UpdateVenue_FullMethodName         = "/venue.VenueService/UpdateVenue"
	VenueService_DeleteVenue_FullMethodName         = "/venue.VenueService/DeleteVenue"
	VenueService_ListVenues_FullMethodName          = "/venue.VenueService/ListVenues"
	VenueService_SearchVenues_FullMethodName        = "/venue.VenueService/SearchVenues"
	VenueService_GetVenuesByLocation_FullMethodName = "/venue.VenueService/GetVenuesByLocation"
)

// VenueServiceClient is the client API for VenueService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Venue Service - Core venue management
type VenueServiceClient interface {
	// CRUD operations for venues
	CreateVenue(ctx context.Context, in *CreateVenueRequest, opts ...grpc.CallOption) (*CreateVenueResponse, error)
	GetVenue(ctx context.Context, in *GetVenueRequest, opts ...grpc.CallOption) (*GetVenueResponse, error)
	UpdateVenue(ctx context.Context, in *UpdateVenueRequest, opts ...grpc.CallOption) (*UpdateVenueResponse, error)
	DeleteVenue(ctx context.Context, in *DeleteVenueRequest, opts ...grpc.CallOption) (*DeleteVenueResponse, error)
	ListVenues(ctx context.Context, in *ListVenuesRequest, opts ...grpc.CallOption) (*ListVenuesResponse, error)
	// Venue search and filtering
	SearchVenues(ctx context.Context, in *SearchVenuesRequest, opts ...grpc.CallOption) (*SearchVenuesResponse, error)
	GetVenuesByLocation(ctx context.Context, in *GetVenuesByLocationRequest, opts ...grpc.CallOption) (*GetVenuesByLocationResponse, error)
}

type venueServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVenueServiceClient(cc grpc.ClientConnInterface) VenueServiceClient {
	return &venueServiceClient{cc}
}

func (c *venueServiceClient) CreateVenue(ctx context.Context, in *CreateVenueRequest, opts ...grpc.CallOption) (*CreateVenueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateVenueResponse)
	err := c.cc.Invoke(ctx, VenueService_CreateVenue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *venueServiceClient) GetVenue(ctx context.Context, in *GetVenueRequest, opts ...grpc.CallOption) (*GetVenueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVenueResponse)
	err := c.cc.Invoke(ctx, VenueService_GetVenue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *venueServiceClient) UpdateVenue(ctx context.Context, in *UpdateVenueRequest, opts ...grpc.CallOption) (*UpdateVenueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateVenueResponse)
	err := c.cc.Invoke(ctx, VenueService_UpdateVenue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *venueServiceClient) DeleteVenue(ctx context.Context, in *DeleteVenueRequest, opts ...grpc.CallOption) (*DeleteVenueResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteVenueResponse)
	err := c.cc.Invoke(ctx, VenueService_DeleteVenue_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *venueServiceClient) ListVenues(ctx context.Context, in *ListVenuesRequest, opts ...grpc.CallOption) (*ListVenuesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListVenuesResponse)
	err := c.cc.Invoke(ctx, VenueService_ListVenues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *venueServiceClient) SearchVenues(ctx context.Context, in *SearchVenuesRequest, opts ...grpc.CallOption) (*SearchVenuesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SearchVenuesResponse)
	err := c.cc.Invoke(ctx, VenueService_SearchVenues_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *venueServiceClient) GetVenuesByLocation(ctx context.Context, in *GetVenuesByLocationRequest, opts ...grpc.CallOption) (*GetVenuesByLocationResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetVenuesByLocationResponse)
	err := c.cc.Invoke(ctx, VenueService_GetVenuesByLocation_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VenueServiceServer is the server API for VenueService service.
// All implementations must embed UnimplementedVenueServiceServer
// for forward compatibility.
//
// Venue Service - Core venue management
type VenueServiceServer interface {
	// CRUD operations for venues
	CreateVenue(context.Context, *CreateVenueRequest) (*CreateVenueResponse, error)
	GetVenue(context.Context, *GetVenueRequest) (*GetVenueResponse, error)
	UpdateVenue(context.Context, *UpdateVenueRequest) (*UpdateVenueResponse, error)
	DeleteVenue(context.Context, *DeleteVenueRequest) (*DeleteVenueResponse, error)
	ListVenues(context.Context, *ListVenuesRequest) (*ListVenuesResponse, error)
	// Venue search and filtering
	SearchVenues(context.Context, *SearchVenuesRequest) (*SearchVenuesResponse, error)
	GetVenuesByLocation(context.Context, *GetVenuesByLocationRequest) (*GetVenuesByLocationResponse, error)
	mustEmbedUnimplementedVenueServiceServer()
}

// UnimplementedVenueServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedVenueServiceServer struct{}

func (UnimplementedVenueServiceServer) CreateVenue(context.Context, *CreateVenueRequest) (*CreateVenueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateVenue not implemented")
}
func (UnimplementedVenueServiceServer) GetVenue(context.Context, *GetVenueRequest) (*GetVenueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVenue not implemented")
}
func (UnimplementedVenueServiceServer) UpdateVenue(context.Context, *UpdateVenueRequest) (*UpdateVenueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateVenue not implemented")
}
func (UnimplementedVenueServiceServer) DeleteVenue(context.Context, *DeleteVenueRequest) (*DeleteVenueResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteVenue not implemented")
}
func (UnimplementedVenueServiceServer) ListVenues(context.Context, *ListVenuesRequest) (*ListVenuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListVenues not implemented")
}
func (UnimplementedVenueServiceServer) SearchVenues(context.Context, *SearchVenuesRequest) (*SearchVenuesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SearchVenues not implemented")
}
func (UnimplementedVenueServiceServer) GetVenuesByLocation(context.Context, *GetVenuesByLocationRequest) (*GetVenuesByLocationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVenuesByLocation not implemented")
}
func (UnimplementedVenueServiceServer) mustEmbedUnimplementedVenueServiceServer() {}
func (UnimplementedVenueServiceServer) testEmbeddedByValue()                      {}

// UnsafeVenueServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VenueServiceServer will
// result in compilation errors.
type UnsafeVenueServiceServer interface {
	mustEmbedUnimplementedVenueServiceServer()
}

func RegisterVenueServiceServer(s grpc.ServiceRegistrar, srv VenueServiceServer) {
	// If the following call pancis, it indicates UnimplementedVenueServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&VenueService_ServiceDesc, srv)
}

func _VenueService_CreateVenue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateVenueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VenueServiceServer).CreateVenue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VenueService_CreateVenue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VenueServiceServer).CreateVenue(ctx, req.(*CreateVenueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VenueService_GetVenue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVenueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VenueServiceServer).GetVenue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VenueService_GetVenue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VenueServiceServer).GetVenue(ctx, req.(*GetVenueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VenueService_UpdateVenue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateVenueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VenueServiceServer).UpdateVenue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VenueService_UpdateVenue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VenueServiceServer).UpdateVenue(ctx, req.(*UpdateVenueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VenueService_DeleteVenue_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVenueRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VenueServiceServer).DeleteVenue(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VenueService_DeleteVenue_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VenueServiceServer).DeleteVenue(ctx, req.(*DeleteVenueRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VenueService_ListVenues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVenuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VenueServiceServer).ListVenues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VenueService_ListVenues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VenueServiceServer).ListVenues(ctx, req.(*ListVenuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VenueService_SearchVenues_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchVenuesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VenueServiceServer).SearchVenues(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VenueService_SearchVenues_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VenueServiceServer).SearchVenues(ctx, req.(*SearchVenuesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VenueService_GetVenuesByLocation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVenuesByLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VenueServiceServer).GetVenuesByLocation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VenueService_GetVenuesByLocation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VenueServiceServer).GetVenuesByLocation(ctx, req.(*GetVenuesByLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VenueService_ServiceDesc is the grpc.ServiceDesc for VenueService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VenueService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "venue.VenueService",
	HandlerType: (*VenueServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateVenue",
			Handler:    _VenueService_CreateVenue_Handler,
		},
		{
			MethodName: "GetVenue",
			Handler:    _VenueService_GetVenue_Handler,
		},
		{
			MethodName: "UpdateVenue",
			Handler:    _VenueService_UpdateVenue_Handler,
		},
		{
			MethodName: "DeleteVenue",
			Handler:    _VenueService_DeleteVenue_Handler,
		},
		{
			MethodName: "ListVenues",
			Handler:    _VenueService_ListVenues_Handler,
		},
		{
			MethodName: "SearchVenues",
			Handler:    _VenueService_SearchVenues_Handler,
		},
		{
			MethodName: "GetVenuesByLocation",
			Handler:    _VenueService_GetVenuesByLocation_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "venue.proto",
}

const (
	LayoutService_CreateLayout_FullMethodName     = "/venue.LayoutService/CreateLayout"
	LayoutService_GetLayout_FullMethodName        = "/venue.LayoutService/GetLayout"
	LayoutService_UpdateLayout_FullMethodName     = "/venue.LayoutService/UpdateLayout"
	LayoutService_DeleteLayout_FullMethodName     = "/venue.LayoutService/DeleteLayout"
	LayoutService_ListLayouts_FullMethodName      = "/venue.LayoutService/ListLayouts"
	LayoutService_SetDefaultLayout_FullMethodName = "/venue.LayoutService/SetDefaultLayout"
	LayoutService_GetDefaultLayout_FullMethodName = "/venue.LayoutService/GetDefaultLayout"
	LayoutService_ValidateLayout_FullMethodName   = "/venue.LayoutService/ValidateLayout"
)

// LayoutServiceClient is the client API for LayoutService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Layout Service - Canvas-based layout management
type LayoutServiceClient interface {
	// CRUD operations for layouts
	CreateLayout(ctx context.Context, in *CreateLayoutRequest, opts ...grpc.CallOption) (*CreateLayoutResponse, error)
	GetLayout(ctx context.Context, in *GetLayoutRequest, opts ...grpc.CallOption) (*GetLayoutResponse, error)
	UpdateLayout(ctx context.Context, in *UpdateLayoutRequest, opts ...grpc.CallOption) (*UpdateLayoutResponse, error)
	DeleteLayout(ctx context.Context, in *DeleteLayoutRequest, opts ...grpc.CallOption) (*DeleteLayoutResponse, error)
	ListLayouts(ctx context.Context, in *ListLayoutsRequest, opts ...grpc.CallOption) (*ListLayoutsResponse, error)
	// Layout operations
	SetDefaultLayout(ctx context.Context, in *SetDefaultLayoutRequest, opts ...grpc.CallOption) (*SetDefaultLayoutResponse, error)
	GetDefaultLayout(ctx context.Context, in *GetDefaultLayoutRequest, opts ...grpc.CallOption) (*GetDefaultLayoutResponse, error)
	ValidateLayout(ctx context.Context, in *ValidateLayoutRequest, opts ...grpc.CallOption) (*ValidateLayoutResponse, error)
}

type layoutServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewLayoutServiceClient(cc grpc.ClientConnInterface) LayoutServiceClient {
	return &layoutServiceClient{cc}
}

func (c *layoutServiceClient) CreateLayout(ctx context.Context, in *CreateLayoutRequest, opts ...grpc.CallOption) (*CreateLayoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateLayoutResponse)
	err := c.cc.Invoke(ctx, LayoutService_CreateLayout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layoutServiceClient) GetLayout(ctx context.Context, in *GetLayoutRequest, opts ...grpc.CallOption) (*GetLayoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetLayoutResponse)
	err := c.cc.Invoke(ctx, LayoutService_GetLayout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layoutServiceClient) UpdateLayout(ctx context.Context, in *UpdateLayoutRequest, opts ...grpc.CallOption) (*UpdateLayoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateLayoutResponse)
	err := c.cc.Invoke(ctx, LayoutService_UpdateLayout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layoutServiceClient) DeleteLayout(ctx context.Context, in *DeleteLayoutRequest, opts ...grpc.CallOption) (*DeleteLayoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteLayoutResponse)
	err := c.cc.Invoke(ctx, LayoutService_DeleteLayout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layoutServiceClient) ListLayouts(ctx context.Context, in *ListLayoutsRequest, opts ...grpc.CallOption) (*ListLayoutsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListLayoutsResponse)
	err := c.cc.Invoke(ctx, LayoutService_ListLayouts_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layoutServiceClient) SetDefaultLayout(ctx context.Context, in *SetDefaultLayoutRequest, opts ...grpc.CallOption) (*SetDefaultLayoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SetDefaultLayoutResponse)
	err := c.cc.Invoke(ctx, LayoutService_SetDefaultLayout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layoutServiceClient) GetDefaultLayout(ctx context.Context, in *GetDefaultLayoutRequest, opts ...grpc.CallOption) (*GetDefaultLayoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetDefaultLayoutResponse)
	err := c.cc.Invoke(ctx, LayoutService_GetDefaultLayout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *layoutServiceClient) ValidateLayout(ctx context.Context, in *ValidateLayoutRequest, opts ...grpc.CallOption) (*ValidateLayoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ValidateLayoutResponse)
	err := c.cc.Invoke(ctx, LayoutService_ValidateLayout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LayoutServiceServer is the server API for LayoutService service.
// All implementations must embed UnimplementedLayoutServiceServer
// for forward compatibility.
//
// Layout Service - Canvas-based layout management
type LayoutServiceServer interface {
	// CRUD operations for layouts
	CreateLayout(context.Context, *CreateLayoutRequest) (*CreateLayoutResponse, error)
	GetLayout(context.Context, *GetLayoutRequest) (*GetLayoutResponse, error)
	UpdateLayout(context.Context, *UpdateLayoutRequest) (*UpdateLayoutResponse, error)
	DeleteLayout(context.Context, *DeleteLayoutRequest) (*DeleteLayoutResponse, error)
	ListLayouts(context.Context, *ListLayoutsRequest) (*ListLayoutsResponse, error)
	// Layout operations
	SetDefaultLayout(context.Context, *SetDefaultLayoutRequest) (*SetDefaultLayoutResponse, error)
	GetDefaultLayout(context.Context, *GetDefaultLayoutRequest) (*GetDefaultLayoutResponse, error)
	ValidateLayout(context.Context, *ValidateLayoutRequest) (*ValidateLayoutResponse, error)
	mustEmbedUnimplementedLayoutServiceServer()
}

// UnimplementedLayoutServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedLayoutServiceServer struct{}

func (UnimplementedLayoutServiceServer) CreateLayout(context.Context, *CreateLayoutRequest) (*CreateLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateLayout not implemented")
}
func (UnimplementedLayoutServiceServer) GetLayout(context.Context, *GetLayoutRequest) (*GetLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetLayout not implemented")
}
func (UnimplementedLayoutServiceServer) UpdateLayout(context.Context, *UpdateLayoutRequest) (*UpdateLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLayout not implemented")
}
func (UnimplementedLayoutServiceServer) DeleteLayout(context.Context, *DeleteLayoutRequest) (*DeleteLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteLayout not implemented")
}
func (UnimplementedLayoutServiceServer) ListLayouts(context.Context, *ListLayoutsRequest) (*ListLayoutsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListLayouts not implemented")
}
func (UnimplementedLayoutServiceServer) SetDefaultLayout(context.Context, *SetDefaultLayoutRequest) (*SetDefaultLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaultLayout not implemented")
}
func (UnimplementedLayoutServiceServer) GetDefaultLayout(context.Context, *GetDefaultLayoutRequest) (*GetDefaultLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDefaultLayout not implemented")
}
func (UnimplementedLayoutServiceServer) ValidateLayout(context.Context, *ValidateLayoutRequest) (*ValidateLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ValidateLayout not implemented")
}
func (UnimplementedLayoutServiceServer) mustEmbedUnimplementedLayoutServiceServer() {}
func (UnimplementedLayoutServiceServer) testEmbeddedByValue()                       {}

// UnsafeLayoutServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LayoutServiceServer will
// result in compilation errors.
type UnsafeLayoutServiceServer interface {
	mustEmbedUnimplementedLayoutServiceServer()
}

func RegisterLayoutServiceServer(s grpc.ServiceRegistrar, srv LayoutServiceServer) {
	// If the following call pancis, it indicates UnimplementedLayoutServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&LayoutService_ServiceDesc, srv)
}

func _LayoutService_CreateLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayoutServiceServer).CreateLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayoutService_CreateLayout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayoutServiceServer).CreateLayout(ctx, req.(*CreateLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayoutService_GetLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayoutServiceServer).GetLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayoutService_GetLayout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayoutServiceServer).GetLayout(ctx, req.(*GetLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayoutService_UpdateLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayoutServiceServer).UpdateLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayoutService_UpdateLayout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayoutServiceServer).UpdateLayout(ctx, req.(*UpdateLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayoutService_DeleteLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayoutServiceServer).DeleteLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayoutService_DeleteLayout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayoutServiceServer).DeleteLayout(ctx, req.(*DeleteLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayoutService_ListLayouts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLayoutsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayoutServiceServer).ListLayouts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayoutService_ListLayouts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayoutServiceServer).ListLayouts(ctx, req.(*ListLayoutsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayoutService_SetDefaultLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDefaultLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayoutServiceServer).SetDefaultLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayoutService_SetDefaultLayout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayoutServiceServer).SetDefaultLayout(ctx, req.(*SetDefaultLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayoutService_GetDefaultLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDefaultLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayoutServiceServer).GetDefaultLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayoutService_GetDefaultLayout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayoutServiceServer).GetDefaultLayout(ctx, req.(*GetDefaultLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LayoutService_ValidateLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LayoutServiceServer).ValidateLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LayoutService_ValidateLayout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LayoutServiceServer).ValidateLayout(ctx, req.(*ValidateLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LayoutService_ServiceDesc is the grpc.ServiceDesc for LayoutService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LayoutService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "venue.LayoutService",
	HandlerType: (*LayoutServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateLayout",
			Handler:    _LayoutService_CreateLayout_Handler,
		},
		{
			MethodName: "GetLayout",
			Handler:    _LayoutService_GetLayout_Handler,
		},
		{
			MethodName: "UpdateLayout",
			Handler:    _LayoutService_UpdateLayout_Handler,
		},
		{
			MethodName: "DeleteLayout",
			Handler:    _LayoutService_DeleteLayout_Handler,
		},
		{
			MethodName: "ListLayouts",
			Handler:    _LayoutService_ListLayouts_Handler,
		},
		{
			MethodName: "SetDefaultLayout",
			Handler:    _LayoutService_SetDefaultLayout_Handler,
		},
		{
			MethodName: "GetDefaultLayout",
			Handler:    _LayoutService_GetDefaultLayout_Handler,
		},
		{
			MethodName: "ValidateLayout",
			Handler:    _LayoutService_ValidateLayout_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "venue.proto",
}

const (
	ZoneService_CreateZone_FullMethodName            = "/venue.ZoneService/CreateZone"
	ZoneService_GetZone_FullMethodName               = "/venue.ZoneService/GetZone"
	ZoneService_UpdateZone_FullMethodName            = "/venue.ZoneService/UpdateZone"
	ZoneService_DeleteZone_FullMethodName            = "/venue.ZoneService/DeleteZone"
	ZoneService_ListZones_FullMethodName             = "/venue.ZoneService/ListZones"
	ZoneService_GetZonesByLayout_FullMethodName      = "/venue.ZoneService/GetZonesByLayout"
	ZoneService_UpdateZoneCoordinates_FullMethodName = "/venue.ZoneService/UpdateZoneCoordinates"
)

// ZoneServiceClient is the client API for ZoneService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Zone Service - Seating zone management
type ZoneServiceClient interface {
	// CRUD operations for zones
	CreateZone(ctx context.Context, in *CreateZoneRequest, opts ...grpc.CallOption) (*CreateZoneResponse, error)
	GetZone(ctx context.Context, in *GetZoneRequest, opts ...grpc.CallOption) (*GetZoneResponse, error)
	UpdateZone(ctx context.Context, in *UpdateZoneRequest, opts ...grpc.CallOption) (*UpdateZoneResponse, error)
	DeleteZone(ctx context.Context, in *DeleteZoneRequest, opts ...grpc.CallOption) (*DeleteZoneResponse, error)
	ListZones(ctx context.Context, in *ListZonesRequest, opts ...grpc.CallOption) (*ListZonesResponse, error)
	// Zone operations
	GetZonesByLayout(ctx context.Context, in *GetZonesByLayoutRequest, opts ...grpc.CallOption) (*GetZonesByLayoutResponse, error)
	UpdateZoneCoordinates(ctx context.Context, in *UpdateZoneCoordinatesRequest, opts ...grpc.CallOption) (*UpdateZoneCoordinatesResponse, error)
}

type zoneServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewZoneServiceClient(cc grpc.ClientConnInterface) ZoneServiceClient {
	return &zoneServiceClient{cc}
}

func (c *zoneServiceClient) CreateZone(ctx context.Context, in *CreateZoneRequest, opts ...grpc.CallOption) (*CreateZoneResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateZoneResponse)
	err := c.cc.Invoke(ctx, ZoneService_CreateZone_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) GetZone(ctx context.Context, in *GetZoneRequest, opts ...grpc.CallOption) (*GetZoneResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetZoneResponse)
	err := c.cc.Invoke(ctx, ZoneService_GetZone_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) UpdateZone(ctx context.Context, in *UpdateZoneRequest, opts ...grpc.CallOption) (*UpdateZoneResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateZoneResponse)
	err := c.cc.Invoke(ctx, ZoneService_UpdateZone_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) DeleteZone(ctx context.Context, in *DeleteZoneRequest, opts ...grpc.CallOption) (*DeleteZoneResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteZoneResponse)
	err := c.cc.Invoke(ctx, ZoneService_DeleteZone_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) ListZones(ctx context.Context, in *ListZonesRequest, opts ...grpc.CallOption) (*ListZonesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListZonesResponse)
	err := c.cc.Invoke(ctx, ZoneService_ListZones_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) GetZonesByLayout(ctx context.Context, in *GetZonesByLayoutRequest, opts ...grpc.CallOption) (*GetZonesByLayoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetZonesByLayoutResponse)
	err := c.cc.Invoke(ctx, ZoneService_GetZonesByLayout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneServiceClient) UpdateZoneCoordinates(ctx context.Context, in *UpdateZoneCoordinatesRequest, opts ...grpc.CallOption) (*UpdateZoneCoordinatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateZoneCoordinatesResponse)
	err := c.cc.Invoke(ctx, ZoneService_UpdateZoneCoordinates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ZoneServiceServer is the server API for ZoneService service.
// All implementations must embed UnimplementedZoneServiceServer
// for forward compatibility.
//
// Zone Service - Seating zone management
type ZoneServiceServer interface {
	// CRUD operations for zones
	CreateZone(context.Context, *CreateZoneRequest) (*CreateZoneResponse, error)
	GetZone(context.Context, *GetZoneRequest) (*GetZoneResponse, error)
	UpdateZone(context.Context, *UpdateZoneRequest) (*UpdateZoneResponse, error)
	DeleteZone(context.Context, *DeleteZoneRequest) (*DeleteZoneResponse, error)
	ListZones(context.Context, *ListZonesRequest) (*ListZonesResponse, error)
	// Zone operations
	GetZonesByLayout(context.Context, *GetZonesByLayoutRequest) (*GetZonesByLayoutResponse, error)
	UpdateZoneCoordinates(context.Context, *UpdateZoneCoordinatesRequest) (*UpdateZoneCoordinatesResponse, error)
	mustEmbedUnimplementedZoneServiceServer()
}

// UnimplementedZoneServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedZoneServiceServer struct{}

func (UnimplementedZoneServiceServer) CreateZone(context.Context, *CreateZoneRequest) (*CreateZoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateZone not implemented")
}
func (UnimplementedZoneServiceServer) GetZone(context.Context, *GetZoneRequest) (*GetZoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetZone not implemented")
}
func (UnimplementedZoneServiceServer) UpdateZone(context.Context, *UpdateZoneRequest) (*UpdateZoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateZone not implemented")
}
func (UnimplementedZoneServiceServer) DeleteZone(context.Context, *DeleteZoneRequest) (*DeleteZoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteZone not implemented")
}
func (UnimplementedZoneServiceServer) ListZones(context.Context, *ListZonesRequest) (*ListZonesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListZones not implemented")
}
func (UnimplementedZoneServiceServer) GetZonesByLayout(context.Context, *GetZonesByLayoutRequest) (*GetZonesByLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetZonesByLayout not implemented")
}
func (UnimplementedZoneServiceServer) UpdateZoneCoordinates(context.Context, *UpdateZoneCoordinatesRequest) (*UpdateZoneCoordinatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateZoneCoordinates not implemented")
}
func (UnimplementedZoneServiceServer) mustEmbedUnimplementedZoneServiceServer() {}
func (UnimplementedZoneServiceServer) testEmbeddedByValue()                     {}

// UnsafeZoneServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ZoneServiceServer will
// result in compilation errors.
type UnsafeZoneServiceServer interface {
	mustEmbedUnimplementedZoneServiceServer()
}

func RegisterZoneServiceServer(s grpc.ServiceRegistrar, srv ZoneServiceServer) {
	// If the following call pancis, it indicates UnimplementedZoneServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ZoneService_ServiceDesc, srv)
}

func _ZoneService_CreateZone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateZoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).CreateZone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZoneService_CreateZone_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).CreateZone(ctx, req.(*CreateZoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_GetZone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetZoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).GetZone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZoneService_GetZone_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).GetZone(ctx, req.(*GetZoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_UpdateZone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateZoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).UpdateZone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZoneService_UpdateZone_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).UpdateZone(ctx, req.(*UpdateZoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_DeleteZone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteZoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).DeleteZone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZoneService_DeleteZone_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).DeleteZone(ctx, req.(*DeleteZoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_ListZones_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListZonesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).ListZones(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZoneService_ListZones_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).ListZones(ctx, req.(*ListZonesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_GetZonesByLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetZonesByLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).GetZonesByLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZoneService_GetZonesByLayout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).GetZonesByLayout(ctx, req.(*GetZonesByLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneService_UpdateZoneCoordinates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateZoneCoordinatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneServiceServer).UpdateZoneCoordinates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZoneService_UpdateZoneCoordinates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneServiceServer).UpdateZoneCoordinates(ctx, req.(*UpdateZoneCoordinatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ZoneService_ServiceDesc is the grpc.ServiceDesc for ZoneService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ZoneService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "venue.ZoneService",
	HandlerType: (*ZoneServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateZone",
			Handler:    _ZoneService_CreateZone_Handler,
		},
		{
			MethodName: "GetZone",
			Handler:    _ZoneService_GetZone_Handler,
		},
		{
			MethodName: "UpdateZone",
			Handler:    _ZoneService_UpdateZone_Handler,
		},
		{
			MethodName: "DeleteZone",
			Handler:    _ZoneService_DeleteZone_Handler,
		},
		{
			MethodName: "ListZones",
			Handler:    _ZoneService_ListZones_Handler,
		},
		{
			MethodName: "GetZonesByLayout",
			Handler:    _ZoneService_GetZonesByLayout_Handler,
		},
		{
			MethodName: "UpdateZoneCoordinates",
			Handler:    _ZoneService_UpdateZoneCoordinates_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "venue.proto",
}

const (
	SeatService_CreateSeat_FullMethodName         = "/venue.SeatService/CreateSeat"
	SeatService_GetSeat_FullMethodName            = "/venue.SeatService/GetSeat"
	SeatService_UpdateSeat_FullMethodName         = "/venue.SeatService/UpdateSeat"
	SeatService_DeleteSeat_FullMethodName         = "/venue.SeatService/DeleteSeat"
	SeatService_CreateSeatsBulk_FullMethodName    = "/venue.SeatService/CreateSeatsBulk"
	SeatService_UpdateSeatsBulk_FullMethodName    = "/venue.SeatService/UpdateSeatsBulk"
	SeatService_DeleteSeatsBulk_FullMethodName    = "/venue.SeatService/DeleteSeatsBulk"
	SeatService_GetSeatsByZone_FullMethodName     = "/venue.SeatService/GetSeatsByZone"
	SeatService_GetSeatsByLayout_FullMethodName   = "/venue.SeatService/GetSeatsByLayout"
	SeatService_GetSeatCoordinates_FullMethodName = "/venue.SeatService/GetSeatCoordinates"
)

// SeatServiceClient is the client API for SeatService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
//
// Seat Service - Individual seat management
type SeatServiceClient interface {
	// CRUD operations for seats
	CreateSeat(ctx context.Context, in *CreateSeatRequest, opts ...grpc.CallOption) (*CreateSeatResponse, error)
	GetSeat(ctx context.Context, in *GetSeatRequest, opts ...grpc.CallOption) (*GetSeatResponse, error)
	UpdateSeat(ctx context.Context, in *UpdateSeatRequest, opts ...grpc.CallOption) (*UpdateSeatResponse, error)
	DeleteSeat(ctx context.Context, in *DeleteSeatRequest, opts ...grpc.CallOption) (*DeleteSeatResponse, error)
	// Bulk seat operations
	CreateSeatsBulk(ctx context.Context, in *CreateSeatsBulkRequest, opts ...grpc.CallOption) (*CreateSeatsBulkResponse, error)
	UpdateSeatsBulk(ctx context.Context, in *UpdateSeatsBulkRequest, opts ...grpc.CallOption) (*UpdateSeatsBulkResponse, error)
	DeleteSeatsBulk(ctx context.Context, in *DeleteSeatsBulkRequest, opts ...grpc.CallOption) (*DeleteSeatsBulkResponse, error)
	// Seat queries
	GetSeatsByZone(ctx context.Context, in *GetSeatsByZoneRequest, opts ...grpc.CallOption) (*GetSeatsByZoneResponse, error)
	GetSeatsByLayout(ctx context.Context, in *GetSeatsByLayoutRequest, opts ...grpc.CallOption) (*GetSeatsByLayoutResponse, error)
	GetSeatCoordinates(ctx context.Context, in *GetSeatCoordinatesRequest, opts ...grpc.CallOption) (*GetSeatCoordinatesResponse, error)
}

type seatServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSeatServiceClient(cc grpc.ClientConnInterface) SeatServiceClient {
	return &seatServiceClient{cc}
}

func (c *seatServiceClient) CreateSeat(ctx context.Context, in *CreateSeatRequest, opts ...grpc.CallOption) (*CreateSeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSeatResponse)
	err := c.cc.Invoke(ctx, SeatService_CreateSeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatServiceClient) GetSeat(ctx context.Context, in *GetSeatRequest, opts ...grpc.CallOption) (*GetSeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSeatResponse)
	err := c.cc.Invoke(ctx, SeatService_GetSeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatServiceClient) UpdateSeat(ctx context.Context, in *UpdateSeatRequest, opts ...grpc.CallOption) (*UpdateSeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSeatResponse)
	err := c.cc.Invoke(ctx, SeatService_UpdateSeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatServiceClient) DeleteSeat(ctx context.Context, in *DeleteSeatRequest, opts ...grpc.CallOption) (*DeleteSeatResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSeatResponse)
	err := c.cc.Invoke(ctx, SeatService_DeleteSeat_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatServiceClient) CreateSeatsBulk(ctx context.Context, in *CreateSeatsBulkRequest, opts ...grpc.CallOption) (*CreateSeatsBulkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateSeatsBulkResponse)
	err := c.cc.Invoke(ctx, SeatService_CreateSeatsBulk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatServiceClient) UpdateSeatsBulk(ctx context.Context, in *UpdateSeatsBulkRequest, opts ...grpc.CallOption) (*UpdateSeatsBulkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(UpdateSeatsBulkResponse)
	err := c.cc.Invoke(ctx, SeatService_UpdateSeatsBulk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatServiceClient) DeleteSeatsBulk(ctx context.Context, in *DeleteSeatsBulkRequest, opts ...grpc.CallOption) (*DeleteSeatsBulkResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(DeleteSeatsBulkResponse)
	err := c.cc.Invoke(ctx, SeatService_DeleteSeatsBulk_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatServiceClient) GetSeatsByZone(ctx context.Context, in *GetSeatsByZoneRequest, opts ...grpc.CallOption) (*GetSeatsByZoneResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSeatsByZoneResponse)
	err := c.cc.Invoke(ctx, SeatService_GetSeatsByZone_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatServiceClient) GetSeatsByLayout(ctx context.Context, in *GetSeatsByLayoutRequest, opts ...grpc.CallOption) (*GetSeatsByLayoutResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSeatsByLayoutResponse)
	err := c.cc.Invoke(ctx, SeatService_GetSeatsByLayout_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *seatServiceClient) GetSeatCoordinates(ctx context.Context, in *GetSeatCoordinatesRequest, opts ...grpc.CallOption) (*GetSeatCoordinatesResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(GetSeatCoordinatesResponse)
	err := c.cc.Invoke(ctx, SeatService_GetSeatCoordinates_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SeatServiceServer is the server API for SeatService service.
// All implementations must embed UnimplementedSeatServiceServer
// for forward compatibility.
//
// Seat Service - Individual seat management
type SeatServiceServer interface {
	// CRUD operations for seats
	CreateSeat(context.Context, *CreateSeatRequest) (*CreateSeatResponse, error)
	GetSeat(context.Context, *GetSeatRequest) (*GetSeatResponse, error)
	UpdateSeat(context.Context, *UpdateSeatRequest) (*UpdateSeatResponse, error)
	DeleteSeat(context.Context, *DeleteSeatRequest) (*DeleteSeatResponse, error)
	// Bulk seat operations
	CreateSeatsBulk(context.Context, *CreateSeatsBulkRequest) (*CreateSeatsBulkResponse, error)
	UpdateSeatsBulk(context.Context, *UpdateSeatsBulkRequest) (*UpdateSeatsBulkResponse, error)
	DeleteSeatsBulk(context.Context, *DeleteSeatsBulkRequest) (*DeleteSeatsBulkResponse, error)
	// Seat queries
	GetSeatsByZone(context.Context, *GetSeatsByZoneRequest) (*GetSeatsByZoneResponse, error)
	GetSeatsByLayout(context.Context, *GetSeatsByLayoutRequest) (*GetSeatsByLayoutResponse, error)
	GetSeatCoordinates(context.Context, *GetSeatCoordinatesRequest) (*GetSeatCoordinatesResponse, error)
	mustEmbedUnimplementedSeatServiceServer()
}

// UnimplementedSeatServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedSeatServiceServer struct{}

func (UnimplementedSeatServiceServer) CreateSeat(context.Context, *CreateSeatRequest) (*CreateSeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSeat not implemented")
}
func (UnimplementedSeatServiceServer) GetSeat(context.Context, *GetSeatRequest) (*GetSeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSeat not implemented")
}
func (UnimplementedSeatServiceServer) UpdateSeat(context.Context, *UpdateSeatRequest) (*UpdateSeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSeat not implemented")
}
func (UnimplementedSeatServiceServer) DeleteSeat(context.Context, *DeleteSeatRequest) (*DeleteSeatResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSeat not implemented")
}
func (UnimplementedSeatServiceServer) CreateSeatsBulk(context.Context, *CreateSeatsBulkRequest) (*CreateSeatsBulkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSeatsBulk not implemented")
}
func (UnimplementedSeatServiceServer) UpdateSeatsBulk(context.Context, *UpdateSeatsBulkRequest) (*UpdateSeatsBulkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateSeatsBulk not implemented")
}
func (UnimplementedSeatServiceServer) DeleteSeatsBulk(context.Context, *DeleteSeatsBulkRequest) (*DeleteSeatsBulkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSeatsBulk not implemented")
}
func (UnimplementedSeatServiceServer) GetSeatsByZone(context.Context, *GetSeatsByZoneRequest) (*GetSeatsByZoneResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSeatsByZone not implemented")
}
func (UnimplementedSeatServiceServer) GetSeatsByLayout(context.Context, *GetSeatsByLayoutRequest) (*GetSeatsByLayoutResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSeatsByLayout not implemented")
}
func (UnimplementedSeatServiceServer) GetSeatCoordinates(context.Context, *GetSeatCoordinatesRequest) (*GetSeatCoordinatesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSeatCoordinates not implemented")
}
func (UnimplementedSeatServiceServer) mustEmbedUnimplementedSeatServiceServer() {}
func (UnimplementedSeatServiceServer) testEmbeddedByValue()                     {}

// UnsafeSeatServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SeatServiceServer will
// result in compilation errors.
type UnsafeSeatServiceServer interface {
	mustEmbedUnimplementedSeatServiceServer()
}

func RegisterSeatServiceServer(s grpc.ServiceRegistrar, srv SeatServiceServer) {
	// If the following call pancis, it indicates UnimplementedSeatServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&SeatService_ServiceDesc, srv)
}

func _SeatService_CreateSeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServiceServer).CreateSeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeatService_CreateSeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServiceServer).CreateSeat(ctx, req.(*CreateSeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeatService_GetSeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServiceServer).GetSeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeatService_GetSeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServiceServer).GetSeat(ctx, req.(*GetSeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeatService_UpdateSeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServiceServer).UpdateSeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeatService_UpdateSeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServiceServer).UpdateSeat(ctx, req.(*UpdateSeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeatService_DeleteSeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSeatRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServiceServer).DeleteSeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeatService_DeleteSeat_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServiceServer).DeleteSeat(ctx, req.(*DeleteSeatRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeatService_CreateSeatsBulk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSeatsBulkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServiceServer).CreateSeatsBulk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeatService_CreateSeatsBulk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServiceServer).CreateSeatsBulk(ctx, req.(*CreateSeatsBulkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeatService_UpdateSeatsBulk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateSeatsBulkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServiceServer).UpdateSeatsBulk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeatService_UpdateSeatsBulk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServiceServer).UpdateSeatsBulk(ctx, req.(*UpdateSeatsBulkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeatService_DeleteSeatsBulk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSeatsBulkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServiceServer).DeleteSeatsBulk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeatService_DeleteSeatsBulk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServiceServer).DeleteSeatsBulk(ctx, req.(*DeleteSeatsBulkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeatService_GetSeatsByZone_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSeatsByZoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServiceServer).GetSeatsByZone(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeatService_GetSeatsByZone_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServiceServer).GetSeatsByZone(ctx, req.(*GetSeatsByZoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeatService_GetSeatsByLayout_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSeatsByLayoutRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServiceServer).GetSeatsByLayout(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeatService_GetSeatsByLayout_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServiceServer).GetSeatsByLayout(ctx, req.(*GetSeatsByLayoutRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SeatService_GetSeatCoordinates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSeatCoordinatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SeatServiceServer).GetSeatCoordinates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SeatService_GetSeatCoordinates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SeatServiceServer).GetSeatCoordinates(ctx, req.(*GetSeatCoordinatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SeatService_ServiceDesc is the grpc.ServiceDesc for SeatService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SeatService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "venue.SeatService",
	HandlerType: (*SeatServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateSeat",
			Handler:    _SeatService_CreateSeat_Handler,
		},
		{
			MethodName: "GetSeat",
			Handler:    _SeatService_GetSeat_Handler,
		},
		{
			MethodName: "UpdateSeat",
			Handler:    _SeatService_UpdateSeat_Handler,
		},
		{
			MethodName: "DeleteSeat",
			Handler:    _SeatService_DeleteSeat_Handler,
		},
		{
			MethodName: "CreateSeatsBulk",
			Handler:    _SeatService_CreateSeatsBulk_Handler,
		},
		{
			MethodName: "UpdateSeatsBulk",
			Handler:    _SeatService_UpdateSeatsBulk_Handler,
		},
		{
			MethodName: "DeleteSeatsBulk",
			Handler:    _SeatService_DeleteSeatsBulk_Handler,
		},
		{
			MethodName: "GetSeatsByZone",
			Handler:    _SeatService_GetSeatsByZone_Handler,
		},
		{
			MethodName: "GetSeatsByLayout",
			Handler:    _SeatService_GetSeatsByLayout_Handler,
		},
		{
			MethodName: "GetSeatCoordinates",
			Handler:    _SeatService_GetSeatCoordinates_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "venue.proto",
}
